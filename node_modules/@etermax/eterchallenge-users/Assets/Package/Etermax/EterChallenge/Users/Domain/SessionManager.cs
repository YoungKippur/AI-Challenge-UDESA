using System;
using Package.Etermax.EterChallenge.Users.Domain.Errors;
using UniRx;

namespace Package.Etermax.EterChallenge.Users.Domain
{
    public partial class SessionManager
    {
        private static SessionManager _defaultInstance;

        /// <summary>
        /// This field is meant to be used only by the Application class alone and should be accessed through
        /// the <code>Application</code> instance.
        /// </summary>
        public static SessionManager Default
        {
            get { return _defaultInstance ?? (_defaultInstance = new SessionManager()); }
        }

        private readonly UserCache _userCache;
        private readonly Subject<User> _onLogout = new Subject<User>();
        private readonly Subject<User> _onBeforeLogout = new Subject<User>();
        private readonly Subject<User> _onLogin = new Subject<User>();
        private readonly Subject<Exception> _onLoginError = new Subject<Exception>();

        public User User
        {
            get { return _userCache.Get(); }
        }

        public string UserId
        {
            get { return User.Id; }
        }

        public string AccessToken
        {
            get { return User.Credentials.AccessToken; }
        }

        public string RefreshToken
        {
            get { return User.Credentials.RefreshToken; }
        }

        public SessionManager()
        {
            _userCache = new UserCache();
        }

        /// <summary>
        /// Event that will be fired when LoginWithXXX action is executed successfully. It returns the authenticated user.
        /// </summary>
        public IObservable<User> OnLogin
        {
            get { return _onLogin; }
        }

        public IObservable<Exception> OnLoginError
        {
            get { return _onLoginError; }
        }

        public IObservable<User> OnBeforeLogout
        {
            get { return _onBeforeLogout; }
        }

        /// <summary>
        /// Event that will be fired when Logout action is executed successfully. It returns a new guest user.
        /// </summary>
        public IObservable<User> OnLogout
        {
            get { return _onLogout; }
        }

        /// <summary>
        /// Returns true or false if the Session has a user in the cache.
        /// </summary>
        /// <returns>bool</returns>
        public bool HasUser()
        {
            var user = _userCache.Get();
            return user != null;
        }

        /// <summary>
        /// Will return the user that is in the cache. If no user is found it will return empty. Useful to combine this and CreateUser at the beginning of the application.
        /// </summary>
        /// <returns>A previously created User</returns>
        public IObservable<User> Resume()
        {
            return Observable.Create<User>(emitter =>
            {
                var user = _userCache.Get();

                if (user != null)
                {
                    emitter.OnNext(user);
                }

                emitter.OnCompleted();
                return Disposable.Empty;
            }).SubscribeOnMainThread();
        }

        /// <summary>
        /// The term authenticated means that the user has 1 or more identities. ex: email or facebook
        /// </summary>
        /// <returns>bool</returns>
        public bool IsAuthenticated()
        {
            var user = _userCache.Get();
            return user != null && user.IsAuthenticated;
        }

        /// <summary>
        /// The term authenticated means that the user has 1 or more identities. ex: email or facebook
        /// </summary>
        /// <returns>bool</returns>
        public bool IsNotAuthenticated()
        {
            return !IsAuthenticated();
        }

        internal void SetNewUser(User user)
        {
            _userCache.Put(user);
        }

        internal void Login(User user)
        {
            SetNewUser(user);
            _onLogin.OnNext(user);
        }

        internal void Logout(User newUser)
        {
            _onBeforeLogout.OnNext(User);
            SetNewUser(newUser);
            _onLogout.OnNext(newUser);
        }

        internal void LoginError(Exception error)
        {
            _onLoginError.OnNext(error);
        }

        internal void UpdateUser(User updatedUser)
        {
            if (User.Id != updatedUser.Id)
                throw new NotSameUserException();

            _userCache.Put(updatedUser);
        }
    }
}